==========
Data Tree
==========

This article is not for the faint of heart. A reasonable understanding of how traversal works is expected.

1. The Structure of a Data Tree
===============================

For our purposes, let's say that the tree is made up of two types of data: Nodes, which are points on the tree that can
have children, and Leaves, which are "exit nodes" or the tip of the branch. A leaf cannot have children, but nodes can.

Both nodes and leaves store an "upwards" reference, or a reference to their "parent" on the data tree. Here's a visual:

.. image:: /images/tree.png

In this visual, you may see that the root node, Node a, has two children, b and c. If we were thinking of this in terms
of a MongoDB Collection, it would look something like:

.. code-block:: json

    {
      [
        {
          id: "a",
          children: ["b", "c"]
        },
        {
          id: "b",
          children: ["d", "e"]
          parent: "a"
        },
        {
          id: "c",
          children: ["f", "g"]
          parent: "a"
        },
        {
          id: "d",
          parent: "b",
          title: "Neat-o."
        },
        {
          id: "e",
          parent: "b",
          title: "I'm a child exit node!"
        },
        {
          id: "f",
          parent: "c",
          title: "I'm c's child."
        },
        {
          id: "g",
          parent: "c",
          title: "I'm c's other special child."
        }
      ]
    }

This seems random, but that's the beauty of Mongo in general. Basically, all of these have an id field (which is conveniently generated by Mongo, but for this example we use our special fields). This is the ID of the node and is the only field we can assume they have. All other fields give us the context. For example, document a has no parent, signifying that it is the root node. Document e has no children, telling us it is an exit node. Document b has children and a parent, so it's just a normal node.

.. note:: Exit nodes have a field called title which you can use to determine if it should be displayed differently. For example, if the exit nodes are supposed to be icons, and the nodes are "categories" that lead to different views, you could use the title field to determine if it's an icon or not.


This is odd when dealing with strict languages like Java. Unlike JavaScript, when you pass an object around you know exactly what methods the object has and what kind it is. In order for the above model to work in Java, you might consider the following:

.. code-block:: java

    @Data
    public class Node {

        // Every instance of Node HAS to have an ID.
        private final String id;
        // The root node won't have a parent. The goal is to abstract it to encompass any node.
        private final Optional<Node> parent;
        // Woah, this looks dangerous.
        private final Optional<List<Optional<Node>> children;
        private final Optional<String> title;

    }

Taking advantage of Optionals, we can make a Node that can encompass any node in the tree. This way, you could make a GuiView class that could handle any node on the tree: It just gets the nodes immediately under the node it is viewing, make icons that link to their respective nodes or do actions in the case of exit nodes, etc.